
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
    <head>
        <title>Recursive Algorithms and Recurrence Equations </title>
    </head>
    <body bgcolor="#ffffff">
        <style>H1 {text-align: Center; COLOR: Green} </style>
        <style>H2 {text-align: Center; COLOR: Red} </style>
        <style>H3 {text-align: Center; COLOR: Blue} </style>
        <h1 >Recursive Algorithms and Recurrence Equations  </h1>

<!-- ************************************ -->
<hr> <hr> 
<h2 > Introduction </h2> 
<h2> Initial Conditions</h2>
<h2> Up and Down Substitution</h2>
<h2> Closed Form</h2>
<hr> <hr> 
<!-- ************************************ -->

<br> 
<!-- ************************************ -->
<br> 
<hr> 
<h3 align=center>Overview</h3>
<ul>
    <li> Performance of recursive algorithms typically specified with 
            <b>recurrence equations</b>  </li>
    <br>
    <li>  Recurrence Equations aka <b> Recurrence</b> and <b> Recurrence Relations</b> </li>
    <ul>
        <li> Recurrence relations have specifically to do with sequences (eg Fibonacci Numbers)

        </li>
    </ul>
    <br>
    <li>  Recurrence equations require special techniques for solving </li>
    <br>
    <li>  We will focus on induction and the Master Method (and its variants) </li>
    <ul>
        <li> And touch on other methods </li>
    </ul>
</ul>

<!-- ************************************ -->
<br> 
<hr> 
<h3 align=center>Analyzing Performance of Non-Recursive Routines is (relatively) Easy</h3>
<ul>
    <li> Loop: <i>T(n)</i> = $\Theta(n)$  </li>
    <pre>
    for i in 1 .. n loop
    </pre>
    <li> Loop: <i>T(n)</i> = $\Theta(n^2)$  </li>
    <pre>
    for i in 1 .. n loop
        for j in 1 .. n loop
        end loop;
    end loop;

    for i in 1 .. n loop
        for j in 1 .. i loop
        end loop;
    end loop;
    </pre>
    <li> Loop: <i>T(n)</i> = $\Theta(n^3)$ ... obvious  </li>
</ul>

<!-- ************************************ -->
<br> 
<hr> 
<h3 align=center>Analyzing Recursive Routines</h3>
<ul>
    <li>  Analysis of recursive routines is not as easy: consider factorial </li>
    <pre>
    fac(n) is
        if <i>n</i> = 1 then return 1
        else return fac(<i>n</i>-1) * 1
    </pre>
    <li>  How many times is fac called for fac(<i>n</i>)? </li>
    <br> 
    <li>  To find an answer, Use a recurrence </li>

</ul>

<!-- ************************************ -->
<br> 
<hr> 
<h3 align=center>Recurrences</h3>
<ul>
    <li> A recurrence defines <i>T(n)</i> in terms of <i>T</i> for smaller values </li>
    <br>
    <li> Example:<i> T(n) = T(n-1) + 1</i>    </li>
    <ul>
        <li> <i>T(n)</i> is defined in terms of <i>T(n-1)</i> </li>
    </ul>
    <br> 
    <li>  Recurrences are used in analyzing recursive algorithms  </li>
    <br>
    <li>  AKA: Recurrence Equation, Recurrence Relation </li>
</ul>

<!-- ************************************ -->
<br> 
<hr> 
<h3 align=center>Evaluating a Recurrence </h3>
<ul>
    <li>  How to think about <i>T(n) = T(n-1) + 1</i> </li>
    <br> 
    <li>  How to find the value of a <i>T(k)</i>  for a particular <i> k</i>:  </li>
    <ul>
        <li> Substitute up from <i> T(1) </i> to <i> T(k) </i></li>
        <li> Substitute down from <i> T(k) </i> to <i> T(1) </i></li>
        <br> 
        <li>  Solving the recurrence and evaluate the resulting expression </li>
    </ul>
    <br>
    <li>  All three methods require having the <b> initial conditions</b> for the recurrence </li>
</ul>



<!-- ************************************ -->
<br> 
<hr> 
<h3 align=center>Initial Conditions </h3>
<ul>
    <li> The initial conditions are the values of the recurrence for small values of n </li>
    <br> 
    <ul>
    <li>  For example, the values of <i>T</i>(0), <i>T</i>(1), <i>T</i>(2) </li>
    </ul>
    <br> 
    <li>  We will see that the initial conditions are determined by 
    the specific problem being solved </li>
    <ul>
        <li> A Recurrence Equation has multiple solutions, </li>
        <li> The initial conditions determines which of those solutions applies. </li>

    </ul>
</ul>

<!-- ************************************ -->
<br> 
<hr> 
<h3 align=center>Substituting Up and Down </h3>
<ul>
    <li>  Problem: Find value of T(n) = T(n-1) + 1 for n=4, with initial condition T(1)=2  </li>
    <br> 
    <li>  Substituting up from T(1): </li>
    <ul>
        <li> T(1) = 2, Initial condition</li>
        <li> T(2) = T(1) + 1 = 2+1 = 3</li>
        <li> T(3) = T(2) + 1 = 3+1 = 4</li>
        <li> T(4) = T(3) + 1 = 4+1 = 5</li>
    </ul>
    <br> 
    <li>  Subsituting down from T(4): </li>
    <ul>
        <li> Example: T(4) = T(3) + 1 = [T(2) + 1] + 1 = [[T(1) + 1] + 1] + 1 = 2+1+1+1 = 5</li>
    </ul>
</ul>

<!-- ************************************ -->
<br> 
<hr> 
<h3 align=center>Solving the Recurrence: Closed Forms </h3>
<ul>
    <li>  To solve a recurrence, we find a <b>closed form</b> for it </li>
    <ul>
        <li> Closed form for T(n): An equation that defines T(n) using an expression that does
        <b>not</b> involve T </li>
        <ul>
            <li> Example: A closed form for T(<i>n</i>) = T(<i>n</i>-1)+1 is T(<i>n</i>) = <i>n</i>.

            </li>
        </ul>
    </ul>
    <br>
    <li>  Solution techniques - no single method works for all: </li>
    <ul>
        <li> Guess and Check </li>
        <ul>
            <li> Forward substitution </li>
            <li>  Backward Substitution </li>
        </ul>
        <li>  Characteristic equation </li>
        <br> 
        <li> Master method (2 versions) </li>
        <ul>
            <li> Recurrence trees help us think about recurrences and show intuition in Master Method </li>
        </ul>
    </ul>
</ul>
<hr> 

<!-- ************************************ -->
<hr> <hr> <h2 > Solving RE</h2> 
          <h2 > Forward and Backward Substitution, Initial Conditions </h2> <hr> <hr> 
<!-- ************************************ -->



<!-- ************************************ -->
<br> 
<h3 align=center>Guess and Check: Forward Substitution </h3>
<ul>
    <li>  Recurrence: T(n) = T(n-1) + 1, with initial condition t(1) = 2  </li>
    <li>  Look for a pattern: </li>
    <ul>
        <li> T(1) = 2, Initial condition</li>
        <li> T(2) = T(1) + 1 = 2+1 = 3</li>
        <li> T(3) = T(2) + 1 = 3+1 = 4</li>
        <li> T(4) = T(3) + 1 = 4+1 = 5</li>
        <li> T(5) = T(4) + 1 = 5+1 = 6</li>
    </ul>
    <li>  Guess: </li>
    <ul>
        <li> T(n) = n + 1 </li>
    </ul>
    <br>
    <li>  Informal Check: </li>
    <ul>
        <li>  T(n) = T(n-1)+1 = [(n-1)+1] + 1 = n+1 </li>
        <li>  T(1) = 1+1 = 2 </li>
    </ul>
    <br>
    <li>  Informally: a closed form is correct if it satisfies the open form and
    the initial conditions  </li>
    <br> 
    <li>  Formally: Prove the closed form is correct using induction (example below) </li>
</ul>


<!-- ************************************ -->
<br> 
<hr> 
<h3 align=center>Guess and Check: Backward Substitution </h3>
<ul>
    <li>  Look for a pattern (how many 1's in each line?): </li>
    <ul>
        <li> T(n) = T(n-1) + 1</li>
        <li> T(n) = [T(n-2)+1] + 1</li>
        <li> T(n) = [[T(n-3)+1]+1] + 1</li>
        <li> T(n) = [[[T(n-4)+1]+1]+1] + 1</li>
        <li>  ...  </li>
        <li> T(n) = [...[[T(n-k)+1]+1] ... +1] + 1 [has k ones]</li>
        <li>  ...  [Let k = n-1] </li>
        <li> T(n) = [...[[T(n-(n-1))+1]+1] ... +1] + 1 [has k=n-1 ones]</li>
        <li> T(n) = T(n-(n-1)) + (n - 1) </li>
        <li> T(n) = T(1) + (n-1)</li>
        <li> T(n) = 2 + (n - 1) </li>
        <li> T(n) = n + 1 </li>
        
    </ul>
    <li>  This process leads to this Guess: </li>
    <ul>
        <li> T(n) = n + 1 </li>
    </ul>
    <br>
    <li>  Check the guess, by substituting, as in the previous example:</li>
    <ul>
        <li>  T(n) = T(n-1)+1 = [(n-1)+1] + 1 = n+1 </li>
        <li>  T(1) = 1+1 = 2 </li>
    </ul>
</ul>


<!-- ************************************ -->
<br> 
<hr> 
<h3 align=center>Recurrences Without Initial Conditions </h3>
<ul>
    <li>  A recurrence without initial conditions is satisfied by a <b>family</b> of closed forms </li>
    <br>
    <li>  Example: Recurrence T(n) = T(n-1) + 1 is satisfied by each member of this
    family of closed forms: </li>
    <ul>
        <li> T(n) = n </li>
        <li> T(n) = n + 1 </li>
        <li> T(n) = n + 2 </li>
        <li>  ...  </li>
        <li> T(n) = n - 1 </li>
        <li> T(n) = n - 2 </li>
        <li>  ...  </li>
    </ul>
    <br> 
    <li>  With specific initial conditions, only one of that family satisfies both the recurrence
    and the initial conditions </li>
    <br> 
    <li>  Example: Recurrence T(n) = T(n-1) + 1 with Initial Condition T(1) = 1 is satisfied by: </li>
    <ul>
        <li> T(n) = n </li>
    </ul>
    <li>  Example: Recurrence T(n) = T(n-1) + 1 with Initial Condition T(1) = 0 is satisfied by: </li>
    <ul>
        <li> T(n) = n - 1 </li>
    </ul>
</ul>

<!-- ************************************ -->
<br> 
<hr> 
<h3 align=center>Initial Conditions and Solutions - More Examples </h3>
<ul>
    <li>  The solution to a recurrence is determined by its initial condition </li>
    <li>  Example 1: </li>
    <ul>
        <li> T(n) = T(n-1) + 1 </li>
        <li> T(1) = 2 </li>
        <li> Guess: T(n) = n + 1 </li>
        <li> Check: as above </li>
        <ul>
            <li>  T(n) = T(n-1)+1 = [n-1+1] + 1 = n+1 </li>
            <li>  T(1) = 1+1 = 2 </li>
        </ul>
    </ul>
    <br> 
    <li>  Example 2: </li>
    <ul>
        <li> T(n) = T(n-1) + 1 </li>
        <li> T(1) = 1 </li>
        <li> Guess: T(n) = n  </li>
        <li>  Check, as above: </li>
        <ul>
            <li>  T(n) = T(n-1)+1 = [n-1] + 1 = n </li>
            <li>  T(1) = 1 </li>
        </ul>
    </ul>

    <br> 
    <li>  Initial conditions restrict number of solutions   </li>
    <ul>
        <li> In this case, restricts to one condition </li>
    </ul>
</ul>
<hr> 


<!-- ************************************ -->
<hr> <hr> <h2 > Recurrence Equations for Sample Algorithms </h2> <hr> <hr> 
<!-- ************************************ -->


<!-- ************************************ -->
<br> 
<h3 align=center>Performance of Recursive Routines</h3>
<ul>
    <li>  Let's develop recurrences for some recursive algorithms: </li>
    <ul>
        <li> Factorial </li>
        <li>  Fibonacci </li>
        <li>  Binary Search </li>
        <li>  Towers of Hanoi </li>
    </ul>
    <br> 
    <li>  What shall we count: number of calls, number of multiplies, ... </li>
</ul>

<!-- ************************************ -->
<br> 
<hr> 
<h3 align=center>Performance of Factorial</h3>
<ul>
    <li> Algorithm:  </li>
    <pre>
    fac(n)
        if n = 1 return 1  
        else return n * fac(n-1)
    </pre>
    <li>  For fac(n), how many times is fac called? </li>
    <ul>
        <li> <i>T(n) = T(n-1) + 1</i>    </li>
        <li> <i>T(1) =  1</i>    </li>
        <br> 
        <li> $T(n) = n$  </li>
    </ul>
    <br>
    <li>  Whatever the number of calls is for <i>n</i>-1 is, the calls for <i>n</i> is one larger </li>
</ul>

<!-- ************************************ -->
<br> 
<hr> 
<h3 align=center>Performance of Factorial, revisited</h3>
<ul>
    <li>  For fac(n), how many <b>multiplies</b>? </li>
    <ul>
        <li> <i>T(n) = T(n-1) + 1</i>    </li>
        <li> <i>T(1) =  0</i>    </li>
        <br> 
        <li> Guess: <i>T(n)</i>  = ???  </li>
        <li>  Check: ...  </li>
    </ul>

</ul>

<!-- ************************************ -->
<br> 
<hr> 
<h3 align=center>Performance of Fibonacci</h3>
<ul>
    <li> Algorithm:  </li>
    <pre>
    fib(n)
        if n in 1 .. 2 return 1  
        else return fib(n-1) + fib(n-2)
    </pre>
    <li>  For fib(n), how many times is fib called? </li>
    <ul>
        <li> $T(1) = 1$ </li>
        <li> $T(2) = 1$ </li>
        <li> $T(3) = T(1) + T(2) + 1 = 1 + 1 + 1 = 3 $ </li>
        <li> $T(4) = T(3) + T(2) + 1 = 3 + 1 + 1 = 5 $ </li>
        <li> $T(5) = T(4) + T(3) + 1 = 5 + 3 + 1 = 9 $ </li>
        <br> 
        <li> $T(n) = T(n-1) + T(n-2) + 1  $ </li>
        <br> 
        <li> $T(n) = ?$  [This one's not so easy] </li>
        <ul>
            <li> The text shows that this has exponential behavior </li>
            <ul>
                <li>  Book also uses T(0) = 0 as an initial condition.  </li>
            </ul>
        </ul>
    </ul>
</ul>

<!-- ************************************ -->
<br> 
<hr> 
<h3 align=center>Performance of Recursive Binary Search</h3>
<ul>
    <li> Algorithm (n?, count?):  </li>
    <pre>
    index binsearch(index low, high, keytype S[], keytype x)
        if low &le; high then
            mid = (low + high) / 2
            if x = S[mid] then
                return mid
            elsif x &lt; s[mid] then
                return binsearch(n, low, mid-1, S, x)
            else
                return binsearch(n, mid+1, high, S, x)
        else
            return 0
    end binsearch
    </pre>
    <li>  For binsearch(n), how many times is binsearch called in the worst case? </li>
    <ul>
       <br> 
        <li> <i>T</i>(0) = 1 </li>
        <li> <i>T</i>(1) = 2 </li>
        <li> <i>T</i>(2) = <i>T</i>(1) + 1 = 3 </li>
        <li> <i>T</i>(4) = <i>T</i>(2) + 1 = 4  </li>
        <li> <i>T</i>(8) = <i>T</i>(4) + 1 = 4 + 1 = 5  </li>
        <br> 

        <li> <i>T(n)</i> = <i>T(n</i>/2) + 1   </li>
        <br> 
        <li> Guess: $T(n) = \lg n + 2$ for $n=2^k$   </li> 
        <li>  Informal Check: </li>
            $\begin{align*} 
                T(n) & = T(n/2) + 1 \\
                & = (\lg \frac{n}{2} + 2) + 1 \\
                & = (\lg n - \lg 2 + 2) + 1 \\
                & = (\lg n - 1 + 2) + 1 \\
                & = \lg n  + 2 
            \end{align*} 
            $
        <li>  We can prove $T(n) = \lg n + 2$ by induction ... </li>
        <li>  $T(n) = \Theta(\lg n)$  </li>
        <li>  What do we assume about <i> n</i>? </li>
    </ul>
</ul>

<!-- ************************************ -->
<br> 
<hr> 
<h3 align=center>Towers of Hanoi  </h3>
<ul>
    <li>  Recursive algorithm </li>
    <li>  Recurrence Equation: T(n) = ...  </li>
    <li>  Closed form: ... </li>
</ul>

<!-- ************************************ -->
<br> 
<hr> 
<h3 align=center>More Example Algorithms and their Recurrence Equations  </h3>
<ul>
    <li>  More Eamples - Let's review or figure out these: </li>
    <ul>
        <li> Factorial (Every Case):  </li>
        <br> 
        <li> Fibonacci (Every Case):  </li>
        <br> 
        <li> Binary Search (Worst Case):  </li>
        <br> 
        <li> Quick Sort (Worst Case):  </li>
        <br> 
        <li> Quick Sort(Best Case):  </li>
        <br> 
        <li> Merge Sort(Every Case):  </li>
    </ul>
</ul>


<!-- ************************************ -->
<br> 
<hr> 
<h3 align=center>More Example Algorithms and their Recurrence Equations  </h3>
<ul>
    <li>  More Eamples - Let's review or figure out these: </li>
    <ul>
        <li> Factorial (Every Case): $T(n) = T(n-1) + 1$ </li>
        <br> 
        <li> Fibonacci (Every Case): $T(n) = T(n-1) + T(n-2) + 1$ </li>
        <br> 
        <li> Binary Search (Worst Case): $T(n) = T(n/2) + 1$ </li>
        <br> 
        <li> Quick Sort (Worst Case): $T(n) = T(n-1) + \Theta(n)$ </li>
        <br> 
        <li> Quick Sort(Best Case): $T(n) = 2T(\frac{n}{2}) + \Theta(n)$ </li>
        <br> 
        <li> Merge Sort(Every Case): $T(n) = 2T(\frac{n}{2}) + \Theta(n)$ </li>
    </ul>
    <br>
    <li>  General Forms:  </li>
    <ul>
        <li>  $T(n) = aT(\frac{n}{b}) + f(n)$ </li>
        <li>  $T(n) = aT(n - b) + f(n)$ </li>
    </ul>
</ul>
<hr> 



<!-- ************************************ -->
<hr> <hr> <h2 > Technical Issues and &Theta; on RHS  </h2> <hr> <hr> 
<!-- ************************************ -->

<!-- ************************************ -->
<br> 
<h3 align=center>Technical Issues</h3>
<ul>
    <li>  Floors and Ceilings </li>
    <ul>
        <li> Usually Ignore </li>
        <li> Or assume size is power of 2  </li>
    </ul>
    <br>
    <li>  Initial (or Boundary) conditions </li>
    <ul>
        <li> Frequently we use asymptotic values </li>
        <li>  Example: $T(1) = \Theta(1)$ </li>
    </ul>
    <br>
    <li>  Exact vs asymptotic functions </li>
    <ul>
        <li> Usually asymptotic is good enough </li>
        <li>  Finding exact solutions requires exact boundary conditions </li>
    </ul>

</ul>

<!-- ************************************ -->
<br> 
<hr> 
<h3 align=center>$\Theta(n)$ on the RHS  </h3>
<ul>
    <li> In $T(n) = T(n-1) + \Theta(n)$, the $\Theta(n)$ terms refers to some function
            in $\Theta(n)$ </li>
            <ul>
                <li> That is, $f(n) \in \Theta(n)$

                </li>
            </ul>
    <br>
    <li>  In most cases, the exact function does not affect the asymptotic behavior of $T(n)$ </li>
    <br>
    <li>  This allows us to simplify by ignoring the exact function </li>
</ul>
<hr> 


<!-- ************************************ -->
<hr> <hr> <h2 > Solution Techniques  </h2> <hr> <hr> 
<!-- ************************************ -->


<!-- ************************************ -->
<br> 
<h3 align=center>Recurrence Equations - Solution Techniques</h3>
<ul>
    <li>  No simple way to solve all recurrence equations  </li>
    <br> 
    <li>  Following techniques are used:  </li>
    <ul>
        <li> Guess a solution and use induction to prove its correctness  </li>
        <ul>
            <li>  Use Forward and Backward Substitution to guess, if needed </li>
        </ul>
        <br>
        <li>  Use a <b>general formula</b> (ie the Master Method) </li>
        <ul>
            <li>  For $T(n) = aT(\frac{n}{b}) + cn^k$ [Version in Text] </li>
            <br>
            <li>  For $T(n) = aT(\frac{n}{b}) + f(n)$ [More general version,
                  NIB, but in CLR </li>
        </ul>
        <br> 
        <li>  Solve using <b>Characteristic Equation</b> </li>
        <ul>
            <li> Linear homogeneous equations with constant coefficients  </li>
            <li> Non-linear homogeneous equations with constant coefficients  </li>
        </ul>
        <br>
        <li>  Change of Variable </li>
    </ul>
    <br>
    <li>  We focus on the general formulae and touch on the others </li>
    <ul>
        <li> General formulae can be understood using <b>recursion trees</b> </li>
        <li>  First we see an example of induction </li>
    </ul>
</ul>
<hr> 

<!-- ************************************ -->
<hr> <hr> <h2 > Checking Recurrence Closed Forms Using Induction </h2> <hr> <hr> 
<!-- ************************************ -->


<!-- ************************************ -->
<br> 
<h3 align=center>Check Using Induction: Factorial [SKIP] </h3>
<ul>
    <li>  For fac(n), how many times is fac called (every case)? </li>

    <li>  Above we derived: </li>
    <ul>
        <li> <i>T(1) = 1</i> </li>
        <li> <i>T(k) = T(k - 1) + 1</i>   </li>
        <br> 
        <li> <i>T(n) = n</i>  </li>
    </ul>
    <br> 
    <li>  Inductive proof that $T(n) = n \text{ is a solution of }T(n) = T(n-1) + 1$, with initial
    condition T(1)=1: </li>
    <ol>
        <li>  Base Case: Prove $T(n) = n \text{ is a solution }$ for <i> n</i> = 1.  <i>T</i>(1) = 1 is an initial condition.   </li>
        <li>  Inductive Step: Prove:  For all $n \gt 1, T(n) = n \text{ is a solution} \implies T(n+1) =
        n+1$ is a solution  </li>
        <ul>
            <li>  Inductive Hypothesis: $T(n) = n$ is a solution </li>
            <li>  Now consider <i>T(n) + 1</i>: </li>

            $\begin{align*} 
                T(n+1) & = T((n+1)-1) + 1 \\
                     &   = T(n) + 1 \\
                     & = n + 1\textrm{, by IH} \\
            \end{align*} 
            $
            <li>  This proves the Inductive Step </li>
        </ul>
        <li> Therefore from 1 and 2, by induction, we conclude that $T(n) = n \text{ for all } n &ge; 1$  </li>
    </ol>

</ul>


<!-- ************************************ -->
<br> 
<hr> 
<h3 align=center>Example Using Induction: Binary Search [SKIP] </h3>
<ul>
    <li>  Worst case number of calls of binary search (assume <i> n</i> is a power of 2</li>
    <ul>
        <li>Recurrence:  $T(n) = T(n/2) + 1 \text{ with } T(1)=2 $  [Derived above]</li>
        <br> 
        <li>Closed form:  $T(n) = \lg n + 2$ [Guessed above.] </li>
    </ul>
    <br> 
    <li>  Inductive proof that closed form is solution for recurrence (assume powers of 2): </li>
    <ol>
        <li>  Base Case: Prove for 1: $T(1) = \lg 1 + 2 = 0 + 2 = 2$. </li>
        <li>  Inductive Step: Prove: that $T(k) = \lg k + 2, \textrm{ for all } k &lt; n$ </li>
        <li>  Inductive Step: Prove:  For all $n \gt 1, T(n) = \lg n + 2, \text{ is a solution}
        \implies T(2n) = \lg 2n +2 = \lg n +3$ is a solution  </li>
        <ul>
            <li>  IH: Assume that $T(k) = \lg k + 2, \textrm{ for all } k &lt; n$ </li>
            <li>  Now consider $T(2n)$: </li>
            $\begin{align*} 
            T(2n) & = T(2n/2) + 1\text{,  by recurrence} \\
                    & = T(n)  + 1   \\
                    & = (\lg n + 2) + 1, \text{ by IH} \\
                    & = \lg n + 3
            \end{align*} 
            $
            <li>  This proves the Inductive Step </li>
        </ul>
        <br> 
        <li> Therefore from 1 and 2 we conclude that $T(n) =\lg n +2 \text{ is a solution to the
        recurrence for all } n &ge; 1$, where <i> n</i> is a power of 2  </li>
        <ul>
            <li> Can also be proved for non-powers of 2 </li>
        </ul>
    </ol>

</ul>
<hr> 


<!-- ************************************ -->
<hr> <hr> <h2 > Master Method  </h2> <hr> <hr> 
<!-- ************************************ -->

<!-- ************************************ -->
<br> 
<hr> 
<h3 align=center>Master Method from Text </h3>
<ul>
    <li>  Cookbook way of solving recurrences of this form:</li>
    <ul>
        <li>  $T(n) = aT(\frac{n}{b}) + \Theta(n^d)$</li>
        <li>  $T(1) = c$ </li>
        <br> 
        <li>  $n = b^k$, for positive integer $k$</li>
        <li> $a \ge 1, b \ge 2, c \gt 0, d \ge 0$ are constants </li>
    </ul>
    <br> 
    <li>  $
    T(n) \in
    \begin{cases}
       \Theta(n^d),          & a &lt; b^d  \\
       \Theta(n^d\lg n),     & a = b^d  \\
       \Theta(n^{\log_b a)}, & a &gt; b^d 
    \end{cases}
    $
    </li>
    <br>
    <li>  We call these Case 1, Case 2, and Case 3. </li>
    <br>
    <li>  Intuition: Which term of recurrence dominates (ie contributes more) </li>
    <br>
    <li>  In the recurrence we can replace 
    "<i>T(n)=</i>" with "<i>T(n)&le;</i>" or "<i>T(n)&ge;</i>" and get $O$ or $\Omega$ performance </li>
</ul>


<!-- ************************************ -->
<br> 
<hr> 
<h3 align=center> Examples using Master Method from Text</h3>
<ul>
    <li>  $T(n) = 16T(n/4) + 5n^3$ </li>
    <ul>
        <li>  $a=16, b=4, d=3$ </li>
        <li> 16 &lt; 4<sup>3</sup> and so Case 1 </li>
        <li> Thus, $T(n) =  \Theta(n^d) = \Theta(n^3)$ </li>
    </ul>
    <br> 
    <li>  $T(n) = 2T(n/2) + n$ </li>
    <ul>
        <li>  $a=2, b=2, d=1$ </li>
        <li> 2 = 2<sup>1</sup> and so Case 2 </li>
        <li> Thus, $T(n) =  \Theta(n^1\lg n)$ </li>
    </ul>
    <br> 
    <li>  $T(n) = 8T(n/2) + n$ </li>
    <ul>
        <li>  $a=8, b=2, d=1$, </li>
        <li> 8 &gt; 2<sup>1</sup> and so Case 3 </li>
        <li> Thus, $T(n) = \Theta(n^{\log_b a}) = \Theta(n^{\lg 8}) = \Theta(n^3)$ </li>
    </ul>
</ul>
<hr> 


<!-- ************************************ -->
<br> 
<h3 align=center> General Master Method [Not In Book] </h3>
<ul>
    <li>  Solve $T(n) = aT(\frac{n}{b}) + f(n)$ </li>
    <li> The MM in the text is a special case version of this one </li>
    <ul>
        <li>  Text's MM's 3 cases are special cases of the GMM 3 cases </li>
    </ul>
    <br> 
    <li>  $
    T(n) \in
    \begin{cases}
    \Theta(f(n)),          & f(n) = \Omega(n^{log_b a+\epsilon}) \text{ and } af(n/b) &le;
    cf(n) \text{ for some constant } c &le; 1 \text{ and large } n  
    \\
       \Theta(n^{\log_b a}\lg n),     & f(n) = \Theta(n^{log_b a})\\
       \Theta(n^{\log_b a)}, &  f(n) = O(n^{log_b a-\epsilon})
    \end{cases}
    $
    </li>
    <br> 
    <li>  Assume $0 &lt; \epsilon$ </li>
    <br>
    <li>  Case 1 can also be written as $n^{log_b a+\epsilon} = O(f(n))$ </li>
    <li> We ignore Case 1 because of its more complex condition </li>
</ul>

<!-- ************************************ -->
<br> 
<hr> 
<h3 align=center> Examples </h3>
<ul>
    <li>  $T(n) = 2T(n/2) + n$ </li>
    <ul>
        <li>  $a=2, b=2, f(n)=n, \log_b a = \lg 2 = 1$ </li>
        <li> Case 2: $f(n) = n = n^1 = \Theta(n^{\log_b a})$ </li>
        <li> Thus, $T(n) =  \Theta(n^{\log_b a}\lg n) = \Theta(n \lg n)$ </li>
    </ul>
    <br> 
    <li>  $T(n) = 8T(n/2) + n$ </li>
    <ul>
        <li>  $a=8, b=2, f(n)=n, \log_b a = \log_2 8 = 3$ </li>
        <li> Case 3: $f(n) = n =  O(n^{3-1})$, with $\epsilon=1$ </li>
        <li> Thus, $T(n) = \Theta(n^{\log_b a}) = \Theta(n^{\lg 8}) = \Theta(n^3)$ </li>
    </ul>
</ul>



<!-- ************************************ -->
<br> 
<hr> 
<h3 align=center>Text's Master Method vs General MM </h3>
<ul>
    <li>  The text's Master Method is a special case of the general Master Method: </li>
    <br> 
    <ul>
        <li>  Assume $T(n) = aT(n/k) + \Theta(n^d)$ meets the conditions for the Text's Case 2, ie $a = b^k$.  
        </li>

        <li>
        Taking log of both sides of $a = b^d$ gives  $log_b a = log_b b^d = d$.
        </li>

        <li>
        Thus, $f(n) \in \Theta( n^d)$ means $cn^{log_b a} \in \Theta(n^{log_b a})$ 
        which is the condition for Case 2 in the General Master Method.
        </li>

        <li>
        Therefore, if a recurrence meets Case 2 of the Text's MM, then it also meets Case 2 of 
        the General MM.  
        </li>
        
        <li>
        Similar arguments can be made for the other cases.
        </li>

        <!--
         $
        \begin{align*}
        a &lt b^k  &  \Leftrightarrow    \lg a &lt; \lg b^k  \\ 
                   &  \Leftrightarrow    \lg a &lt; k\lg b  \\ 
                   &  \Leftrightarrow    \frac{\lg a}{\lg b} &lt; k  \\ 
                   &  \Leftrightarrow \log_b a &lt; k   \\ 
                   &  \Leftrightarrow n^{\log_b a} &lt;  n^k \\ 
                   &  \Leftrightarrow n^{\log_b a} = O(n^{k-\epsilon})
        \end{align*}
        $
        -->

    </ul>
</ul>



<!-- ************************************ -->
<hr> <hr> <h2 > Other Solution Techniques  </h2> <hr> <hr> 
<!-- ************************************ -->


<!-- ************************************ -->
<br> 
<hr> 
<h3 align=center>Other Methods for Solving Recurrence Equations</h3>
<ul>
        <li>  Characteristic Equation </li>
        <ul>
            <li> Linear homogeneous equations with constant coefficients  </li>
            <li> Non-linear homogeneous equations with constant coefficients  </li>
        </ul>
        <br>
        <li>  Change of Variable </li>
        <br>
        <li>  Substitution </li>
        <br>
        <li>  We look at briefly at the first and ignore the second two</li>
</ul>


<!-- ************************************ -->
<hr> <hr> <h2 > Characteristic Equations  </h2> <hr> <hr> 
<!-- ************************************ -->


<!-- ************************************ -->
<br> 
<hr> 
<h3 align=center>Homogenous Linear Recurrence Equations</h3>
<ul>
    <li> General form: $a_0t_n + a_1t_{n-1} + \dots + a_kt_{n-k} = 0$   </li>
    <ul>
        <li> Slightly different from previous recurrence equations: </li>
        <ul>
            <li> Notation: $t_n$ vs $T(n)$  </li>
            <li> all $t$ terms  on LHS of equation   </li>
            <li> 0 on RHS  of equation  </li>
        </ul>
    </ul>
    <br> 
    <li>  Overview of how to solve: </li>
    <ul>
      <li>  <b> Assume</b> $t_n = r^n$ is a solution for all $n$ and for some
    real number <i> r</i></li>
        <br> 
        <li>  Generate Characteristic Equation:
        <ul>
            <li> Recurrence: $a_0t_n + a_1t_{n-1} + \dots + a_kt_{n-k} = 0$   </li>
            <li>Substitute $r^n$ for $t_n$: $a_0r^n + a_1r^{n-1} + \dots + a_kr^{n-k} = 0$ </li>
            <li>Factor out $r^{n-k}$: $(r^{n-k})(a_0r^k + a_1r^{k-1} + \dots + a_kr^{k-k}) = 0$ </li>
            <li>Divide by $r^{n-k}$  (since it gives a root of r=0, which is not useful)</li>
            <ul>
                <li> Resulting Characteristic Equation: $a_0r^k + a_1r^{k-1} + \dots + a_kr^{k-k} = 0$   </li>
            </ul>
        </ul>
        <br> 
        <li>  Find roots of Characteristic Equation </li>
        <br> 
        <li>  Use roots of Characteristic Equation to form recurrence solution </li>
    </ul>
</ul>


<!-- ************************************ -->
<br> 
<hr> 
<h3 align=center>Homogenous Linear Recurrence Equation: Example</h3>
<ul>
    <li> Notation: $t_n$ vs $T(n)$  </li>
    <br>
    <li> Recurrence: </li>
    <ul>
        <li> $t_n - 5t_{n-1} + 6t_{n-2} = 0$   </li>
        <li> $t_0 = 0$ </li>
        <li> $t_1 = 1$ </li>
    </ul>
    <br> 
    <li>  <b> Assume</b> $t_n = r^n$ is a solution, for all $n$ and for some
    real number <i> r</i></li>
    <br> 
    <li> Substitute: $r^n - 5r^{n-1} + 6r^{n-2}  = 0$   </li>
    <br> 
    <li> Factor: $ r^{n-2}(r^2 - 5r^1 + 6r^0) = 0$   </li>
    <br> 
    <li> Divide by  $ r^{n-2}$ (since it gives a root of r=0, which is not useful)  </li>
    <ul>
        <li> Resulting Characteristic Equation (CE): $r^2 - 5r^1 + 6r^0 = 0$   </li>
    </ul>
    <br> 
    <li> Find roots of CE: $r^2 - 5r^1 + 6r^0 = (r-3)(r-2) = 0$  </li>
    <ul>
        <li> Roots are 3 and 2 </li>
        <li> That is, $r^2 - 5r^1 + 6r^0 = 0$ when $r_1=3$ or $r_2=2$  </li>
    </ul>
    <br> 
    <li>By assumption, $t_n=3^n$ and $t_n=2^n$, are both solutions to the RE (and $t_n=0$, which we ignore).</li>
    <br>
    <ul>
         <li>  (Can verify that T(n) = 5T(-1) -6T(n-2) holds for each solution.) </li>
        <li>Since $t_n=3^n$ and $t_n=2^n$, are both solutions, so is the linear combination: $t_n = \alpha r_1^n + \beta r_2^n= \alpha 3^n + \beta 2^n$ </li>
        <li> Plugging general solution into recurrence and distributing will give 0 </li>
        <li>  General solution defines an infinite number of solutions </li>
        <li>  Use initial conditions to find a single solution </li>
        <li> If roots are identical, use this equation: $t_n = \alpha r^n + \beta nr^n$</li>
    </ul>
    <br>
    <li>  Choose $\alpha$ and $\beta$ to meet the initial conditions:
    $t_0=0,t_1=1$ </li>
    <ul>
        <li> $t_0 = \alpha 3^0 + \beta 2^0 = 0$ </li>
        <li> $t_1 = \alpha 3^1 + \beta 2^1 = 1$ </li>
         <li>  Solving gives: $\alpha=1$ and $\beta = -1$ </li>
    </ul>
    <br>
    <li>  Thus: general solution is $t_n  = \alpha 3^n + \beta 2^n== 3^n - 2^n$ </li>
</ul>

<!-- ************************************ -->
<br> 
<hr> 
<h3 align=center>Homogenous Linear Recurrence Equation: Fibonacci Numbers</h3>
<ul>
    <li> Recurrence: </li>
    <ul>
       <li>  $T(n) = T(n-1) + T(n-2) </li>
        <li> $t_n - t_{n-1} - t_{n-2} = 0$   </li>
        <li> $t_0 = 0$ </li>
        <li> $t_1 = 1$ </li>
    </ul>
    <br> 
    <li>  <b> Assume</b> solution is of form $t_n = r^n$, for all $n$ </li>
    <br> 
    <li> Substitute: $r^n - r^{n-1} - r^{n-2}  = 0$   </li>
    <br> 
    <li> Factor: $ r^{n-2}(r^2 - r^1 - r^0) = 0$   </li>
    <br> 
    <li> Divide by  $ r^{n-2}$ give CE: $r^2 - r^1 - r^0 = 0$   </li>
    <br> 
    <li> Roots of CE: $(1+\sqrt{5})/2=\phi$  and  $(1-\sqrt{5})/2=1-\phi = 1/\phi =
    \hat{\phi}$</li>
    <br>
    <li>  Choose $\alpha$ and $\beta$ to meet the initial conditions:
    $t_0=0,t_1=1$ </li>
    <ul>
       <li> $t_0 = \alpha \phi^0 + \beta \hat{\phi}^0 = 0$ </li>
       <li> $t_1 = \alpha \phi^1 + \beta \hat{\phi}^1 = 1$ </li>
       <li>  Solving gives: $\alpha=1/\sqrt{5}$ and $\beta = -1/\sqrt{5}$ </li>
    </ul>
    <br>
    <li>  Thus: general solution is $t_n  = \alpha \phi^n + \beta \hat{\phi}^n
    = \frac{1}{\sqrt{5}}(\phi^n - \hat{\phi}^n)$ </li>
</ul>

<!-- ************************************ -->
<br> 
<hr> 
<h3 align=center>Non-homogenous Linear Recurrence Equations</h3>
<ul>
    <li> General form: $a_0t_n + a_1t_{n-1} + \dots + a_kt_{n-k} = c \ne 0$   </li>
    <br>
    <li>  RHS &ne; 0 </li>
    <li>  General plan: </li>
    <ul>
        <li> Find roots of related homogeneous equation and find alpha and beta.  </li>
        <li> Form equation (eg  $t_n = \alpha r_1^n + \beta r_2^n$ if distinct roots) and solve for alpha and beta </li>
        <li>  Solution to non-homogeneous is based on solution to homogeneous </li>
    </ul>
    
    <li>  We mostly ignore these   </li>
</ul>

<!-- ************************************ -->
<br> 
<hr> 
<h3 align=center>Change of Variable</h3>
<ul>
    <li>  Substitute, for example, $2^k$ for $n$ </li>
    <li>  Example: For Fibonacci, number of additions </li>
    <ul>
       <li> $t_n = t_{n-1} + t_{n-2} + 1 = 0$ </li>
       <li> $t_n - t_{n-1} - t_{n-2} = 1 $ </li>
       <li> $t_n - t_{n-1} - t_{n-2} -1 = 0 $ </li>
       <li>  Substitute: $u_n = t_n + 1$ </li>
    </ul>
    <li>  We mostly ignore these </li>
</ul>




<!-- ************************************ -->
<hr> <hr> <h2 > Recursion Tree - Intuition for  Master Method </h2> <hr> <hr> 
<!-- ************************************ -->


<!-- ************************************ -->
<br> 
<hr> 
<h3 align=center> Recursion Tree  </h3>
<ul>
    <li>  A Recursion Tree is a technique for calculating the amount of work expressed by a recurrence equation   </li>
    <ul>
        <li> Nice illustration of a recurrence </li>
        <li>  Gives intuition behind Master Methods </li>
    </ul>
    <br>
    <li>  Each level of the tree shows the <b>non-recursive work</b> for a given parameter
    value </li>
    <ul>
        <li> See diagram </li>
    </ul>
    <br>
    <li>  Write each node with two parts:  </li>
    <ul>
        <li> Upper part: $T(s)$ for some $s$ </li>
        <li>  Lower part: non-recursive part of $T(s)$    </li>
    </ul>
    <br>
    <li>  Relation between parts: Upper part = lower part + upper parts of children </li>

</ul>


<!-- ************************************ -->
<br> 
<hr> 
<h3 align=center>Example Recursion Tree </h3>
<ul>
    <li>  Consider $T(n) = 2T(\frac{n}{3}) + 5n$ </li>
    <ul>
        <li> $T(0) = 7$ </li>
        <li> These values don't represent a specific algorithm.  
        They are just chosen for illustration.  </li>
    </ul>

    <br>
    <li>  First rewrite as $T(s) = 5s + 2T(\frac{s}{3})$  </li>
    <ul>
        <li> Putting non-recursive term first is (slightly) easier</li>
        <li>  Using a different variable allows us to focus on calculating $T(n)$ </li>
    </ul>
    <br>
    <li>  Now calculate $T(27) = T(3^3)$: </li>
    <ul>
        <li>  Root is $T(27)$: </li>
        <ul>
            <li> Upper part: $T(27)$ </li>
            <li>  Lower part: $5s=5\times 27 = 135$ </li>
        </ul>
        <br>
        <li>  Children of root: </li>
        <ul>
            <li> How many children? </li>
            <li> What's in each child?  </li>
        </ul>
        <br> 
        <li>  Calculating $T(27)$: </li>

        $\begin{align*}
        T(27) & = 5\times 27 + 2 \times T(27/3)   \\
              & = 135 + 2 \times T(27/3)   \\
              & = 135 + 2 \times [45 + 2 \times T(9/3)]   \\
              & = 135 + 2 \times [45 + 2 \times [15 + 2 \times T(3/3)]]   \\
              & = 135 + 2 \times [45 + 2 \times [15 + 2 \times 7]]   \\
              & = 135 + 2 \times [45 + 2 \times 29]   \\
              & = 135 + 2 \times 103   \\
              & = 135 + 206   \\
              & = 341
        \end{align*}
        $
    </ul>

</ul>


<!-- ************************************ -->
<br> 
<hr> 
<h3 align=center>Example Recursion Tree </h3>
<ul>
    <li>  Consider $T(s) = 2T(\frac{s}{3}) + 5s = 5s + 2T(\frac{s}{3}) $ </li>
    <li>  Calculate $T(27)$  </li>

<center>
              <img src="Diagrams/Recurrence1.gif"></img> 
</center>
<li>  Where do 2, 3, log<sub>3</sub>, log<sub>3</sub> 27 come from?  </li>
</ul>


<!-- ************************************ -->
<br> 
<hr> 
<h3 align=center>Tree Properties</h3>
<ul>
    <li>  Consider $T(s) = 5s + 2T(\frac{s}{3}) $ </li>
    <br> 
    <li>  Bottom level is level $\log_3 27$ = level 3 </li>
    <li>  Number of levels: $ 1 + \log_3 27  = 1 + 3 = 4$ </li>
    <br> 
    <li>  Sum of level 0: $2^0 \times (5\times 27) = 135$ </li>
    <li>  Sum of level 1: $2^1 \times (5\times 9) = 90$ </li>
    <li>  Sum of level 2: $2^2 \times (5\times 3) = 60$ </li>
    <br> 
    <li>  Sum of bottom level: $2^{\log_3 27} * 7 = 2^3 \times 7 = 56$ </li>
    <br> 
    <li>  Sum of all levels: $135 + 90 + 60 + 56 = 341$ </li>
</ul>


<!-- ************************************ -->
<br> 
<hr> 
<h3 align=center>Recursion Tree for $T(n) = aT(\frac{n}{b}) + f(n)$ </h3>
<ul>
    <li> Recurrence Equation: $T(s) = f(s) + a T(s/b)$  </li>
    <ul>
        <li> $T(1) = d$ </li>
    </ul>
    <li>  Find $T(n)$ </li>

<center>
              <img src="Diagrams/Recurrence2.gif"></img> 
</center>
</ul>


<!-- ************************************ -->
<br> 
<hr> 
<h3 align=center>Summing the Values in the Tree </h3>
<ul>
    <li> Recurrence Equation: $T(s) = f(s) + a T(s/b)$  </li>
    <ul>
        <li> $f(0) = d$ </li>
    </ul>
    <br> 
    <li>  Bottom level is level $\log_b n$  </li>
    <li>  Number of levels: $ 1 + \log_b n$    </li>
    <br> 
    <li>  Sum of all levels except leaves: cost of dividing and joining </li>
    <ul>
    <li>  Sum of level 0: $a^0 \times f(\frac{n}{b^0}) $ </li>
    <li>  Sum of level 1: $a^1 \times f(\frac{n}{b^1}) $ </li>
    <li>  Sum of level 2: $a^2 \times f(\frac{n}{b^2}) $ </li>
    <br> 
    <li>  Sum of level i: $a^i \times f(\frac{n}{b^i}) $ </li>
    <br> 
    <li>  Sum of all levels except leaves: $\sum_{i=0}^{\log_b n - 1} a^i f(\frac{n}{b^i})$</li>
    </ul>
    <br> 
    <li>  Sum of bottom level: cost of solving all problems of size 1 </li>
    <ul>
        <li>  $d a^{log_b n} = d n^{log_b a}  $ </li>
    </ul>

    <br> 
    <li>  Sum of all levels:  </li>
    $$
    \sum_{i=0}^{\log_b n - 1} a^i f(\frac{n}{b^i}) + d n^{log_b a} 
    $$ 
</ul>


<!-- ************************************ -->
<br> 
<hr> 
<h3 align=center>Fine Points  </h3>
<ul>
    <li>  $a &ge; 1, b &gt; 1, \text{ are constants}$ </li>
    <br> 
    <li>  If $n$ is not a power of $b$, then replace $n/b$ by $\lfloor n/b \rfloor$ (or
    $\lceil n/b \rceil$) </li>
    <ul>
        <li> It can be proved that this does not affect the complexity </li>
    </ul>
</ul>


<!-- ************************************ -->
<br> 
<hr> 
<h3 align=center>Evaluating the Complexity of the Sum of the Tree Levels </h3>
<ul>
    <li>  Sum of all levels:
    $\displaystyle  \sum_{i=0}^{\log_b n - 1} a^i  f(\frac{n}{b^i}) + \Theta(n^{log_b a}) 
    $ 
    </li>
    <br> 
    <li>  Simplify base case of recursion using $\Theta(1)$ instead of $d$ </li>
    <br> 
    <li>  When this formula is a polynomial in $n$, we can simplify it by 
    considering  the power of $n$ in each term: </li>
    <ul>
        <li>  Either first or second term can dominate or they can be the same order </li>
    </ul>
    <br>
    <li>  Intuitively: </li>
    <ul>
        <li>  $\Theta(f(n))$, if the first term (ie the sum of non-leaf levels) dominates (Case 1)</li>
        <li>  $\Theta(n^{log_b a}\lg n )$, if neither term dominates </li>
        <li>  $\Theta(n^{log_b a})$, if the second term (ie sum of leaves) dominates (Case 3) </li>
        <li>  Some restrictions occur </li>
    </ul>
    <br>
    <li>  These results can be formalized to obtain the General Master Method </li>
</ul>



<!-- ************************************ -->
<br> 
<hr> 
<h3 align=center> Formalizing Gives the General Master Method </h3>
<ul>
    <li>  To formalize, we consider the relation
    between the terms of the sum of the levels. </li>
    <br> 
    <li>  Sum of all levels:
    $\displaystyle
    \sum_{i=0}^{\log_b n - 1} a^i f(\frac{n}{b^i})
    + 
     \Theta(n^{log_b a})  
    $ 
    </li>
    <br> 
    <li>  Formal definition of one term dominating is below (assume $0 &lt; \epsilon$):</li>
    <ul>
        <br> 
        <li>  $\Theta(f(n))$, if $f(n) = \Omega(n^{log_b a+\epsilon})$ and $af(n/b) &le; cf(n)$ for some constant $c &le; 1$ and large $n$ [ie Case 1:
        second term (sum of non-leaves) dominates] </li>
        <br> 
        <li>  $\Theta(n^{log_b a}\lg n )$, if  $f(n) = \Theta(n^{log_b a})$  [ie neither term dominates]</li>
        <br> 
        <li>  $\Theta(n^{log_b a})$, if $f(n) = O(n^{log_b a-\epsilon})$ [ie Case 3: second term (sum of leaves) dominates]</li>
        <ul>
            <li>  This can also be written as $n^{log_b a+\epsilon} = O(f(n))$ </li>
            <li> We ignore this case </li>
        </ul>
    </ul>
    <br>
    <li>  These results give the general Master Method </li>
</ul>




<hr> 
<hr> 
<br> <br> <br> <br> <br> <br>
<br> <br> <br> <br> <br> <br> 
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({ 
       tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']]}
    });
</script>
<script type="text/javascript" 
    src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'>
</script>

    </body>
</html> 
