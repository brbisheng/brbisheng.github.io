---
markdown: kramdown
title: Pass-by-value vs. pass-by-reference
categories: ["rcpp", "cpp"]
---

There is a great example on Pass-by-value vs. pass-by-reference from Stroustrup.


void somefunc(int a, int& b, const int& c) {

  ++a;           // change the object a by 1 locally
                 // the value of the global variable will not be changed! (same as in r)
                 // if we want to change the global variable, we need to pass by reference.
                 
  ++b;           // increase by 1 the object referred to by b 
  int d = c;     // read the object referred to by c, assign its value to d

}

int main() {

  int x = 0;
  int y = 0;
  int z = 0;
  somefunc(x,y,z); // result: x==0; y==1; z==0;
                   // as we expected, the value of the object x is not increased.
  somefunc(1,2,3); // error: reference argument b needs a variable to refer to
  somefunc(1,y,3); // OK: since c is const, we can pass a literal.

}

{% highlight c linenos %}
{% endhighlight %}

1. Why does `somefunc(x,y,z)` work?
    - Because `x,y,z` are all objects holding a value.

2. Why does `somefunc(1,2,3)` fail? 
    - Because **the integer 2 is just a value (an rvalue), rather than an object holding a value.** 
    - What we need for `somefunc(.,.,.)`’s second argument `b` must be an **lvalue**, that is, **something that could appear on the left-hand side of an assignment.**
    - a const reference (the third argument of `somefunc`) does not need an **lvalue**. **It can perform conversions exactly as initialization or pass-by-value.**

So, if you want to change the value of an object passed by reference, you have to pass an object. 

3. Basically, what happens in that last call, `somefunc(1,y,3)`, is that the compiler sets aside an int for somefunc()’s argument `c` to refer to:

References:
1. Programming: Principles and Practice Using C++, Bjarne Stroustrup.
